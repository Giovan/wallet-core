// Copyright Â© 2017-2020 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.
//
// This is a GENERATED FILE, changes made here WILL BE LOST.
//

#include "Coin.h"
#include <TrustWalletCore/TWCoinTypeConfiguration.h>

#include <map>

using namespace TW;

struct CoinInfo {
    const char* id;
    const char* name;
    TWBlockchain blockchain;
    TWPurpose purpose;
    TWCurve curve;
    TWHDVersion xpubVersion;
    TWHDVersion xprvVersion;
    DerivationPath derivationPath;
    TWPublicKeyType publicKeyType;
    byte staticPrefix;
    byte p2pkhPrefix;
    byte p2shPrefix;
    TWHRP hrp;
    Hash::Hasher publicKeyHasher;
    Hash::Hasher base58Hasher;
    const char* symbol;
    int decimals;
    const char* explorerTransactionUrl;
    const char* explorerAccounUrl;
};

/// Map with info about known coins
static std::map<TWCoinType, CoinInfo> coins;

/// Fill the map.  Simple static initializer did not work out due to nondeterministic static initialization order
void fillMap() {
    coins = std::map<TWCoinType, CoinInfo> {
    <% coins.each do |coin| -%>
        {
            TWCoinType<%= format_name(coin['name']) %>, {
                "<%= coin['id'] %>",
                <% if coin['displayName'].nil? -%>"<%= coin['name'] %>"<% else -%>"<%= coin['displayName'] %>"<% end -%>,
                TWBlockchain<%= format_name(coin['blockchain']) %>,
                TWPurposeBIP<%= /^m\/(\d+)'?(\/\d+'?)+$/.match(coin['derivationPath'])[1] %>,
                TWCurve<%= format_name(coin['curve']) %>,
                TWHDVersion<% if coin['xpub'].nil? -%>None<% else -%><%= format_name(coin['xpub']) %><% end -%>,
                TWHDVersion<% if coin['xprv'].nil? -%>None<% else -%><%= format_name(coin['xprv']) %><% end -%>,
                DerivationPath("<%= coin['derivationPath'] %>"),
                TWPublicKeyType<%= format_name(coin['publicKeyType']) %>,
                <% if coin['staticPrefix'].nil? -%>0<% else -%><%= coin['staticPrefix'] %><% end -%>,
                <% if coin['p2pkhPrefix'].nil? -%>0<% else -%><%= coin['p2pkhPrefix'] %><% end -%>,
                <% if coin['p2shPrefix'].nil? -%>0<% else -%><%= coin['p2shPrefix'] %><% end -%>,
                TWHRP<% if coin['hrp'].nil? -%>Unknown<% else -%><%= format_name(coin['name']) %><% end -%>,
                Hash::<% if coin['publicKeyHasher'].nil? -%>sha256ripemd<% else -%><%= coin['publicKeyHasher'] %><% end -%>,
                Hash::<% if coin['base58Hasher'].nil? -%>sha256d<% else -%><%= coin['base58Hasher'] %><% end -%>,
                "<%= coin['symbol'] %>",
                <%= coin['decimals'] %>,
                "<%= explorer_tx_url(coin) %>",
                "<%= explorer_account_url(coin) %>",
            }
        },
    <% end -%>
    };
}

// Helpers

static const CoinInfo defaultsForMissing = {
    "?",
    "?",
    TWBlockchainBitcoin,
    TWPurposeBIP44,
    TWCurveED25519,
    TWHDVersionNone,
    TWHDVersionNone,
    DerivationPath(),
    TWPublicKeyTypeSECP256k1,
    0,
    0,
    0,
    TWHRPUnknown,
    Hash::sha256ripemd,
    Hash::sha256d,
    "?",
    2,
    "",
    "",
};

/// Get coin from map, if missing returns defaults (not to have contains-check in each accessor method)
const CoinInfo& getCoinInfo(TWCoinType coin) {
    if (coins.size() == 0) { fillMap(); }
    if (coins.find(coin) == coins.end()) { return defaultsForMissing; }
    return coins.at(coin);
}

// Accessors

TWBlockchain TW::blockchain(TWCoinType coin) {
    return getCoinInfo(coin).blockchain;
}

TWPurpose TW::purpose(TWCoinType coin) {
    return getCoinInfo(coin).purpose;
}

TWCurve TW::curve(TWCoinType coin) {
    return getCoinInfo(coin).curve;
}

TWHDVersion TW::xpubVersion(TWCoinType coin) {
    return getCoinInfo(coin).xpubVersion;
}

TWHDVersion TW::xprvVersion(TWCoinType coin) {
    return getCoinInfo(coin).xprvVersion;
}

DerivationPath TW::derivationPath(TWCoinType coin) {
    return getCoinInfo(coin).derivationPath;
}




enum TWPublicKeyType TW::publicKeyType(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWPublicKeyType<%= format_name(coin['publicKeyType']) %>;
<% end -%>
    }
}

byte TW::staticPrefix(TWCoinType coin) {
    switch (coin) {
<% coins.select{ |coin| coin.has_key?('staticPrefix') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['staticPrefix'] %>;
<% end -%>
    default: return 0;
    }
}

byte TW::p2pkhPrefix(TWCoinType coin) {
    switch (coin) {
<% coins.select{ |coin| coin.has_key?('p2pkhPrefix') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['p2pkhPrefix'] %>;
<% end -%>
    default: return 0;
    }
}

byte TW::p2shPrefix(TWCoinType coin) {
    switch (coin) {
<% coins.select{ |coin| coin.has_key?('p2shPrefix') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['p2shPrefix'] %>;
<% end -%>
    default: return 0;
    }
}

enum TWHRP TW::hrp(TWCoinType coin) {
    switch (coin) {
<% coins.select{ |coin| coin.has_key?('hrp') }.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return TWHRP<%= format_name(coin['name']) %>;
<% end -%>
    default: return TWHRPUnknown;
    }
}

Hash::Hasher TW::publicKeyHasher(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<% if coin['publicKeyHasher'].nil? -%>
        return Hash::sha256ripemd;
<% else -%>
        return Hash::<%= coin['publicKeyHasher'] %>;
<% end -%>
<% end -%>
    }
}

Hash::Hasher TW::base58Hasher(TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<% if coin['base58Hasher'].nil? -%>
        return Hash::sha256d;
<% else -%>
        return Hash::<%= coin['base58Hasher'] %>;
<% end -%>
<% end -%>
    }
}

TWString *_Nullable TWCoinTypeConfigurationGetSymbol(enum TWCoinType coin) {
    std::string string;
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        string = "<%= coin['symbol'] %>";
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

int TWCoinTypeConfigurationGetDecimals(enum TWCoinType coin) {
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        return <%= coin['decimals'] %>;
<% end -%>
    }
}

TWString *_Nullable TWCoinTypeConfigurationGetTransactionURL(enum TWCoinType coin, TWString *_Nonnull transactionID) {
    std::string url;
    std::string txId = TWStringUTF8Bytes(transactionID);
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        url = "<%= explorer_tx_url(coin) %>" + txId;
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(url.c_str());
}

TWString *_Nullable TWCoinTypeConfigurationGetAccountURL(enum TWCoinType coin, TWString *_Nonnull accountID) {
    std::string url;
    std::string accId = TWStringUTF8Bytes(accountID);
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        url = "<%= explorer_account_url(coin) %>" + accId;
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(url.c_str());
}

TWString *_Nonnull TWCoinTypeConfigurationGetID(enum TWCoinType coin) {
    std::string string;
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
        string = "<%= coin['id'] %>";
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(string.c_str());
}

TWString *_Nonnull TWCoinTypeConfigurationGetName(enum TWCoinType coin) {
    std::string string;
    switch (coin) {
<% coins.each do |coin| -%>
    case TWCoinType<%= format_name(coin['name']) %>:
<% if coin['displayName'].nil? -%>
    string = "<%= coin['name'] %>";
<% else -%>
    string = "<%= coin['displayName'] %>";
<% end -%>
        break;
<% end -%>
    }
    return TWStringCreateWithUTF8Bytes(string.c_str());
}
